#pragma kernel CSMain
#pragma kernel CSMain2

#define WRITE_BLUR(color, position) \
{float4 WRITE_existing = _Buffer[position]; \
if (WRITE_existing.a == 0.0) \
{ \
	_Buffer[position] = color; \
} \
else \
{ \
	_Buffer[position] = max(WRITE_existing, color); \
}}

RWTexture2D<float4> _UIInput;
RWTexture2D<float4> _Buffer;
RWTexture2D<float4> _Buffer2;
float _decay;

[numthreads(12,1,1)]
void CSMain (uint3 dtid : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex) 
{
	uint2 start = dtid.xy;

	float4 inputColor = _UIInput[start];
	float4 bufferColor = _Buffer[start];

	int startPixelY = (int)(dtid.y * 12 + dtid.x);
	int startOutputY = (int)(startPixelY * 2.75);

	int startY = (int)(dtid.y * 33 + dtid.x * 2.75);

	for (int x = 0; x < 1200; x++)
	{
		// _Buffer[uint2(x, startOutputY)] = float4(x / 1200.0f, 0.0, 0.0, 1.0);
		float4 inputColor = _UIInput[uint2(1200-x, 792-startOutputY)];
		// get max of above and below
		[unroll]for (int yOffset = -1; yOffset <= 0; yOffset++)
		{
			if (startY + yOffset >= 0 && startY + yOffset < 792)
			{
				float4 neighborColor = _UIInput[uint2(1200 - x, 792 - (startOutputY + yOffset))];
				if (neighborColor.r > inputColor.r) inputColor.r = neighborColor.r;
				if (neighborColor.g > inputColor.g) inputColor.g = neighborColor.g;
				if (neighborColor.b > inputColor.b) inputColor.b = neighborColor.b;
			}
		}
		if (inputColor.x <= 0 && inputColor.y <= 0 && inputColor.z <= 0)
		{
			//continue;
		}
		inputColor.a = 1.0;

		_Buffer[uint2(x, startY)] = inputColor;
		
		inputColor *= 0.5;
		inputColor.a = 0.0;

		WRITE_BLUR(inputColor, uint2(x, startY + 1));
		WRITE_BLUR(inputColor, uint2(x, startY - 1));
		WRITE_BLUR(inputColor, uint2(x - 1, startY));
		WRITE_BLUR(inputColor, uint2(x + 1, startY));

	}
	return;
}
[numthreads(8,8,1)]
void CSMain2 (uint3 dtid : SV_DispatchThreadID)
{
	uint2 start = dtid.xy;
	float4 inputColor = _Buffer[start];
	float4 bufferColor = _Buffer2[start];
	bool new_input = inputColor.r > bufferColor.r || inputColor.g > bufferColor.g || inputColor.b > bufferColor.b;

	if (new_input)
	{
		bufferColor.r = inputColor.r > 0 ? inputColor.r : 0.0;
		bufferColor.g = inputColor.g > 0 ? inputColor.g : 0.0;
		bufferColor.b = inputColor.b > 0 ? inputColor.b : 0.0;
	}
	else
	{
		bufferColor -= _decay * float4(1,1,1,1);
		if (bufferColor.r < inputColor.r)
		{
			bufferColor = inputColor;
		}
	}
	bufferColor.a = 1.0;

    _Buffer2[dtid.xy] = bufferColor;
	_Buffer[dtid.xy] = float4(0, 0, 0, 0);
}
